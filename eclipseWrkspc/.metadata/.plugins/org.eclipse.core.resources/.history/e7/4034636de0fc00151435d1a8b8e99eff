package videomap;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.regex.Pattern;

public class ImageClient {
	
	private String address;
	private int port;
	private File folder;
	private int numFiles;
	private String basename;
	private int currentFile;
	private Socket clientSocket;
	private byte[] buffer;
	private static int BUFFER_SIZE = (int) (1024 * 1024 * 1.0);
	
	public ImageClient(String address, int port, String folder, int totalFiles, String baseName) {
		setAddress(address);
		setPort(port);
		setFolder(folder);
		setNumFiles(totalFiles);
		setBaseName(baseName);
		currentFile = 0;
		clientSocket = null;
		buffer = new byte[BUFFER_SIZE];
	}
	
	public ImageClient(String address, int port) {
		setAddress(address);
		setPort(port);
		setFolder("data" + File.separatorChar);
		setNumFiles(2);
		setBaseName("img-");
		currentFile = 0;
		clientSocket = null;
		buffer = new byte[BUFFER_SIZE];
	}
	
	public void setPort(int port) {
		if (port > 1024 && port < 65000) {
			this.port = port;
		}
	}
	
	public void setAddress(String addres) {		
		final String IPADDRESS_PATTERN = 
				"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
				"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
				"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
				"([01]?\\d\\d?|2[0-4]\\d|25[0-5])$";
		final Pattern pattern = Pattern.compile(IPADDRESS_PATTERN);
	    if (addres != null && pattern.matcher(addres).matches()) {
	        this.address = addres;
	    }
	}
	
	public void setFolder (String folder) {
		if (folder == null) {
			System.out.println("Invalid folder");
			return;
		}
		File file = new File(folder);
		if (file.exists() && file.isDirectory() && file.canWrite()) {
			this.folder = new File(folder);
		}
	}
	
	public void setNumFiles(int numberOfFiles) {
		if (numberOfFiles > 0) {
			this.numFiles = numberOfFiles;
		}
	}
	
	public void setBaseName (String basename) {
		if (basename != null && !basename.isEmpty()) {
			this.basename = basename;
		}
	}
	
	public void connect() {
		try {
			System.out.println("Connecting...");
			this.clientSocket = new Socket(address, port);
			System.out.println("Connection succeded!");
		} catch (UnknownHostException e) {
			System.out.println("Cannot locate the server: " + address);
			e.printStackTrace();
		} catch (IOException e) {
			System.out.println("Cannot shakle hands with the server: " + address);
			e.printStackTrace();
		}
	}
	
	public void receiveFiles() {
		//This should wait receiving files, 
		//for testing I'm just going to do a one pass off all the folder
		for (int i = 0; i < this.numFiles; ++i) {
			this.receiveNextFile();
			this.advanceToNextFile();
		}
	}
	
	private void receiveNextFile() {
	
		BufferedOutputStream bos = null;
		DataInputStream dis = null;
		
		//Open stream for this file
		try {
			dis = new DataInputStream(new BufferedInputStream(clientSocket.getInputStream()));
			bos = new BufferedOutputStream(new FileOutputStream(getFileName()));
		} catch (IOException e) {
			System.out.println("Error trying to receive file: " + getFileName());
			e.printStackTrace();
		}
		
		//Read file by chunks
		try {
			long fileSize = dis.readLong();
			int bytesRead = is.read(this.buffer, 0, buffer.length);
	        int current = bytesRead;
	        
	        while (fileSize > 0 && (n = dis.read(buf, 0, (int)Math.min(buf.length, fileSize)) != -1)
	        		{
	        		  fos.write(buf,0,n);
	        		  fileSize -= n;
	        		}
	        
	        //Recreate file 
	        do {          	
	        	bytesRead = is.read(this.buffer, current, Math.min(this.buffer.length - current, fileSize -current));
	        	if (bytesRead >= 0) {
	        		current += bytesRead;
	        	}
	        } while(bytesRead > -1); //current < fileSize OR current != fileSize
	        
	        bos.write(this.buffer, 0, current);
	        bos.flush();
		} catch (IOException e) {
			System.out.println("Error trying to receive file");
			e.printStackTrace();
		}
		
		
		//Closing stream for this file
		try {
			bos.close();
			fos.close();
		} catch (IOException e) {
			System.out.println("Error trying to close current file connection");
			e.printStackTrace();
		}
         
	}
	
	public String getAddress() {
		return this.address;
	}
	
	public int getPort() {
		return this.port;
	}
	
	public String getFolder() {
		return this.folder.getAbsolutePath();
	}
	
	public int getTotalFilesNumber() {
		return this.numFiles;
	}
	
	public String getBasename() {
		return this.basename;
	}
	
	private String getFileName() {
		return this.basename + String.format("%03d", currentFile);
	}
	
	private void advanceToNextFile() {
		this.currentFile++;
		this.currentFile %= this.numFiles;
	}
}
